---
title: DT_NEEDED HELP !
description: >-
  This blogpost will explain some protection techniques against modification of dynamic program header entries.
author: klcium
date: 2025-07-20 20:55:00 +0800
categories: [Reverse Engineering]
tags: [ELF, Reverse]
pin: false
published: false
---

## Introduction
Last winter, I wanted hook some Android application for a project at work.The primary objective was to bypass the anti-hooking techniques and intercept the exchanged data between a DJI drone and its controlling application prior to a firmware analysis. Long story short, after multiple unsuccessful attempts I left this project on the side but it never really left my mind.
Cracking a program open is like solving a puzzle. There is always a solution, finding it is always a matter of time and efforts. 

Fast forward 10 months later, I came accross an article that I missed from [Nozomi Networks Labs](https://www.nozominetworks.com/blog/dji-mavic-3-drone-research-part-1-firmware-analysis). 

Not only this article surprised me as they already did all the research work more than a year earlier, but they also managed to hook the packing lib and dump the dex files using the exact same techniques that I tried 10 months earlier.

This blog is a retro-analysis on how they did it and what I missed during my initial attempts.

## Presentation of the problem
### Prior work
The DJI Fly ("dji.go.v5") should not be misunderstood with the DJI Pilot application. The latter, (more specifically its packing mechanisms) has already been reverse engineered multiple times by both [Synacktiv](https://www.synacktiv.com/publications/dji-pilot-android-application-security-analysis-0.html) and [Quarkslab](https://blog.quarkslab.com/). I highly recommend you to read Eric Le Guevel's  article [the ART of obfuscation](https://blog.quarkslab.com/dji-the-art-of-obfuscation.html) on which I based my research.

From what I have read, the DJI Pilot is protected by the SecNeo/BangCle wrapper and its protection scheme consists in splitting the classes in multiple encrypted dex files.

Dumping the dex files dynamically seemed pretty "easy": Hook the decrypting function `decrypt_jar_128K` from the `libDexHelper.so` native lib and dump the memory. A less trivial approach would consist in reversing the encryption mechanisms and rebuild the dex files locally.

> Note: in DJI Fly, past 1.12 ~ 1.13 the libDexHelper.so app is renamed libAppGuard.so. But it is the same thing actually.


Since both apps are packed by SecNeo, all I have to do is to reproduce theses steps. **Easy ..right?**

![pic not related](/assets/img/shitpost/kittens/cat_squeeshy.gif)

*(Pic not related)*

Well **obviously not**, otherwise this article wouldn't exist.

- First of all, the `decrypt_jar_128K` method does not exist in DJI Fly.
- Secondly, the DJI Fly unpacking lib comes with some heavily obfuscated anti-frida techniques. 

From a static (and painful) analysis, I believe that the anti-frida code is triggered before the dex classes are finalized. So I spent a lot of time studying what were the anti-frida techniques and how to bypass them.

### Attempts and failures
Amongst the existing methods, I tried to inject a frida-gadget into the unpacking binary. For that, I used [LIEF](https://lief.re/), more specifically their own [tutorial](https://lief.re/doc/stable/tutorials/09_frida_lief.html) to inject a frida gadget into a native lib. 

This technique did not work and the app was no longer booting. To make sure this was not due to the injected gadget, I simply read and save the program usingn LIEF without editing the PT_DYNAMIC table (I will explain this concept further down this article) and yielded the same results.

Is displayed below the PT_DYNAMIC table of the `libAppGuard.so` file *before* injection (*Note: i trimmed the 16 bytes tags into 8 for readability*):

```bash
‚ûú readelf -d libAppGuard.so 
readelf: Error: no .dynamic section in the dynamic segment

Dynamic section at offset 0xefb90 contains 8 entries:
  Tag       Type                 Name/Value
 0x00000001 (NEEDED)             0xcd15
 0x00000001 (NEEDED)             0xcd23
 0x00000001 (NEEDED)             0xcd2d
 0x00000001 (NEEDED)             0xcd35
 0x00000001 (NEEDED)             0xecc7
 0x00000001 (NEEDED)             0xecd0
 0x0000000e (SONAME)             0xed0d
 0x00000000 (NULL)               0x0
```

And after injection:
```bash
‚ûú readelf -d libAppGuard.so.out
readelf: Warning: Section 0 has an out of range sh_link value of 118202
readelf: Error: no .dynamic section in the dynamic segment

Dynamic section at offset 0xefb90 contains 33 entries:
  Tag       Type                 Name/Value
 0x00000001 (NEEDED)             Shared library: [libfrida.so]
 0x00000001 (NEEDED)             Shared library: [libandroid.so]
 0x00000001 (NEEDED)             Shared library: [liblog.so]
 0x00000001 (NEEDED)             Shared library: [libz.so]
 0x00000001 (NEEDED)             Shared library: [libm.so]
 0x00000001 (NEEDED)             Shared library: [libdl.so]
 0x00000001 (NEEDED)             Shared library: [libc.so]
 0x0000000e (SONAME)             Library soname: [libAppGuard.so]
 0x00000019 (INIT_ARRAY)         0xe5240
 0x0000001b (INIT_ARRAYSZ)       8 (bytes)
 0x0000001a (FINI_ARRAY)         0xe5248
 0x0000001c (FINI_ARRAYSZ)       16 (bytes)
 0x00000004 (HASH)               0x228
 0x6ffffef5 (GNU_HASH)           0x29f8
 0x00000005 (STRTAB)             0xe098
 0x00000006 (SYMTAB)             0x52a8
 0x0000000a (STRSZ)              60705 (bytes)
 0x0000000b (SYMENT)             24 (bytes)
 0x00000003 (PLTGOT)             0xe8950
 0x00000002 (PLTRELSZ)           14352 (bytes)
 0x00000014 (PLTREL)             RELA
 0x00000017 (JMPREL)             0x27888
 0x00000007 (RELA)               0x1d9d0
 0x00000008 (RELASZ)             40632 (bytes)
 0x00000009 (RELAENT)            24 (bytes)
 0x0000001e (FLAGS)              BIND_NOW
 0x6ffffffb (FLAGS_1)            Flags: NOW
 0x6ffffffe (VERNEED)            0x1d990
 0x6fffffff (VERNEEDNUM)         2
 0x6ffffff0 (VERSYM)             0x1cdba
 0x6ffffff9 (RELACOUNT)          1093
 0x0000000c (INIT)               0x108098
 0x00000000 (NULL)               0x0
```

Finally here is what you may see if you open the binary with Ghidra to check manually its contents:

![ghidra DT_NEEDED](/assets/img/posts/2025-08-20-DT_NEEDED/ghidra_appguard_injected_PT_DYNAMIC.png)



If you pay attention to the results, you may be asking yourself: 
- Why are there integers instead of names before the injection but not after ? And what about all of the new ones after injection ?
- Why `readelf` uses the word `section` to describe entries instead of `segment` ?
- Why `readelf` can't find the `.dynamic` section ?
- Why are there 6 `DT_NEEDED` tags instead of 7 in the injected library ?
- Why does `readelf` reads the 7th `DT_NEEDED` ?
- What has LIEF done to my binary ?
- Why am I reading this article ?

So many questions left unanswered 
And that's how I said üåû*fuck this shit*üåû and tried some other techniques to find.

> If you can answer all of these questions, congrats. Here is a cookie `JSESSONID=de1dc51aed38a6916826eab84347b25f`.

> To be honest, I was (and am still) a rookie. Progress was slow and spending more time to understand this was not the priority.

### Turning point
After multilpe weeks of failing, I set this project aside to focus on some other projects. The idea was to come back at it once I'd be skilled enough to crack it. But it never really left my mind.

And that's how it went until I found this blogpost from [Nozomi Networks Labs](https://www.nozominetworks.com/blog/dji-mavic-3-drone-research-part-1-firmware-analysis). 

Not only they managed to hook and dump the dex files, but **they did it using this exact same\* method that I tried**.

> "We dump the decrypted .dex files by reading the raw memory layout of the application from /proc/self/maps through a code injection, exploiting DT_NEEDED entries with LIEF from QuarksLab, and inspecting it to extract the unpacked data."

> \* Actually ‚òùÔ∏èü§ì, they used the same technique but did not injected any frida-agent (from what I've understood).

![you did it crazy soab](/assets/img/shitpost/you-crazy-son-of-a-bitch-you-did-it-meme.png)

Unfortunately, their article does not provides more information on how they achieved it. But at least, I now have a proof of the feasability of this technique and that all I have to do now is to *try harder‚Ñ¢*.

## Anatomy of a fail
This article will now explain some required concepts for you to understand this article and eventually explain what went wrong on my side.

### ELF file structure
- Dynamic Linking Process ?
- ELF file structure
    - Segments
    - Sections

Dont forget to make notice that dynamic tags are missing according tot hese links:
https://refspecs.linuxbase.org/elf/gabi4+/ch5.pheader.html
https://refspecs.linuxbase.org/elf/gabi4+/ch5.dynamic.html#dynamic_section

### Readelf internals



### LIEF internals

### How everything comes together

## Answer to all the questions


## Final word