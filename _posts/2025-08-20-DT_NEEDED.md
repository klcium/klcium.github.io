---
title: DT_NEEDED HELP !
description: >-
  This blogpost will explain some protection techniques against modification of dynamic program header entries.
author: klcium
date: 2025-07-20 20:55:00 +0800
categories: [Reverse Engineering]
tags: [ELF, Reverse]
pin: false
published: false
---

## Introduction
Last winter, I tried hook some Android application for a project at work.The objective was to bypass the anti-hooking techniques and intercept the exchanged data between a DJI drone and its controlling application prior to a firmware analysis. Long story short, after multiple unsuccessful attempts I left this project on the side but it never really left my mind.
Cracking a program open is like solving a puzzle. There is always a solution, finding it is always a matter of time and efforts. 

Fast forward 10 months later, I come accross an article that I missed from [Nozomi Networks Labs](https://www.nozominetworks.com/blog/dji-mavic-3-drone-research-part-1-firmware-analysis). 

Not only this article surprised me as they already did all the research work more than a year before myself, they also managed to hook the packing lib and dump the dex files using the exact same techniques that I tried 10 months earlier.

Although I am very glad to have worked on this project, I guess it's over now.
This blog post is a post-mortem report on what I missed and how they managed to pull the trick.

## Presentation of the problem
### Prior work on DJI apps
DJI Fly or in its appname "dji.go.v5" should not be misunderstood which DJI Pilot application. DJI Pilot, more specifically its packer has already been reverse engineered multiple times by both [Synacktiv](https://www.synacktiv.com/publications/dji-pilot-android-application-security-analysis-0.html) and Quarkslab in their article [the ART of obfuscation](https://blog.quarkslab.com/dji-the-art-of-obfuscation.html) which I highly recommend you to read.

From what I have read, the DJI Pilot is protected by the SecNeo/BangCle wrapper and its protection scheme consists in splitting the classes in multiple encrypted dex files.

Dumping the dex files dynamically was pretty "easy". Hook the decrypting function of the `libDexHelper.so` lib and there you go.
Dumping the files statically was a white box cryptography challenge.

> In order to get the full list of exported methods, I had to unpack the packer itself using binary instrumentation tools like [MIASM](https://github.com/cea-sec/miasm). FYI dumping it from memory using Frida is a much simpler solution.
> Note: in DJI Fly, past 1.12 ~ 1.13 the libDexHelper.so app is renamed libAppGuard.so. But it is the same thing actually.


Since both apps are packed by SecNeo, all I have to do is to reproduce theses steps. **Easy ..right?**
![pic not related](/assets/img/shitpost/kittens/cat_squeeshy.gif)

Pic not related

Well obviously not, otherwise this article wouldn't exist.

- First of all, the `decrypt_jar_128K` method does not exist in the DJI Fly packing lib. So I will have to find where they are.
- Secondly, the DJI Fly native unpacking lib comes with some heavily obfuscated anti-frida techniques. 

From a static (and painful) analysis, I believe that the injected frida code is being thrown away before the final dex classes are actually built. So I spent a lot of time studying what were the anti-frida techniques, how to bypass them and pretty much how to make my script stealthy.

### Attempts and failures
Amongst the tried methods, modifying the unpacking binary to trick it into loading my script felt like a good idea.
So I used [LIEF](https://lief.re/), more specifically their own [tutorial](https://lief.re/doc/stable/tutorials/09_frida_lief.html) to inject a frida gadget into a native lib. Felt like charm until I tried to run the program.

So here is the dynamic segment of the `libAppGuard.so` file *before* injection:

*Note: i trimmed the 16 bytes tags into 8 for readability*

```bash
âžœ readelf -d libAppGuard.so 
readelf: Error: no .dynamic section in the dynamic segment

Dynamic section at offset 0xefb90 contains 8 entries:
  Tag               Type                 Name/Value
 0x00000001 (NEEDED)             0xcd15
 0x00000001 (NEEDED)             0xcd23
 0x00000001 (NEEDED)             0xcd2d
 0x00000001 (NEEDED)             0xcd35
 0x00000001 (NEEDED)             0xecc7
 0x00000001 (NEEDED)             0xecd0
 0x0000000e (SONAME)             0xed0d
 0x00000000 (NULL)               0x0
```

And here it is after:
```bash
âžœ readelf -d libAppGuard.so.out
readelf: Warning: Section 0 has an out of range sh_link value of 118202
readelf: Error: no .dynamic section in the dynamic segment

Dynamic section at offset 0xefb90 contains 33 entries:
  Tag       Type                 Name/Value
 0x00000001 (NEEDED)             Shared library: [libfrida.so]
 0x00000001 (NEEDED)             Shared library: [libandroid.so]
 0x00000001 (NEEDED)             Shared library: [liblog.so]
 0x00000001 (NEEDED)             Shared library: [libz.so]
 0x00000001 (NEEDED)             Shared library: [libm.so]
 0x00000001 (NEEDED)             Shared library: [libdl.so]
 0x00000001 (NEEDED)             Shared library: [libc.so]
 0x0000000e (SONAME)             Library soname: [libAppGuard.so]
 0x00000019 (INIT_ARRAY)         0xe5240
 0x0000001b (INIT_ARRAYSZ)       8 (bytes)
 0x0000001a (FINI_ARRAY)         0xe5248
 0x0000001c (FINI_ARRAYSZ)       16 (bytes)
 0x00000004 (HASH)               0x228
 0x6ffffef5 (GNU_HASH)           0x29f8
 0x00000005 (STRTAB)             0xe098
 0x00000006 (SYMTAB)             0x52a8
 0x0000000a (STRSZ)              60705 (bytes)
 0x0000000b (SYMENT)             24 (bytes)
 0x00000003 (PLTGOT)             0xe8950
 0x00000002 (PLTRELSZ)           14352 (bytes)
 0x00000014 (PLTREL)             RELA
 0x00000017 (JMPREL)             0x27888
 0x00000007 (RELA)               0x1d9d0
 0x00000008 (RELASZ)             40632 (bytes)
 0x00000009 (RELAENT)            24 (bytes)
 0x0000001e (FLAGS)              BIND_NOW
 0x6ffffffb (FLAGS_1)            Flags: NOW
 0x6ffffffe (VERNEED)            0x1d990
 0x6fffffff (VERNEEDNUM)         2
 0x6ffffff0 (VERSYM)             0x1cdba
 0x6ffffff9 (RELACOUNT)          1093
 0x0000000c (INIT)               0x108098
 0x00000000 (NULL)               0x0
```

Finally here is what you may see if you open the binary with Ghidra to check manually its contents:

![ghidra DT_NEEDED](/assets/img/posts/2025-08-20-DT_NEEDED/ghidra_appguard_injected_PT_DYNAMIC.png)

And the app is (as expected) not booting. I also tried to simply read and save the program usingn lIEF without editing the DYNAMIC table and had the same results.

**You may be asking yourself**: 
- Why are there integers (spoilers: they are offsets) before the injection but not after ?
- Is `readelf` parsing the `section` or the `segment` ?
- Why does `readelf` says they can't find the `.dynamic` segment and then print the dynamic section ?
- Why are there 6 `DT_NEEDED` tags instead of 7 in the injected library ?
- Why does `readelf` reads the 7th `DT_NEEDED` ?
- What has LIEF done to my binary ?
- Why am I reading this article ?

So many questions left unanswered 
And that's how I said ðŸŒž*fuck this shit*ðŸŒž and tried some other techniques to find.

> If you can answer all of these questions. Congratulations, here is a cookie JSESSONID=de1dc51aed38a6916826eab84347b25f.


> To be honest, I was (and I am still) a rookie. This project is though and the progress was slow and spending more time in troubleshooting this was not a priority.

### Turning point
And that's how it went until I found this blogpost from [Nozomi Networks Labs](https://www.nozominetworks.com/blog/dji-mavic-3-drone-research-part-1-firmware-analysis). 

Not only they managed to hook and dump the dex files, but **they did it using this exact same method**.
As I quote:
> "We dump the decrypted .dex files by reading the raw memory layout of the application from /proc/self/maps through a code injection, exploiting DT_NEEDED entries with LIEF from QuarksLab, and inspecting it to extract the unpacked data."

![you did it crazy soab](/assets/img/shitpost/you-crazy-son-of-a-bitch-you-did-it-meme.png)


So that's all they have to say ?
At least, this sentence is a proof of the feasability of this method and that all I have to do now is to *try harderâ„¢*.

## Anatomy of a fall

### ELF file structure
- ELF file structure
    - Segments
    - Sections

Dont forget to make notice that dynamic tags are missing according tot hese links:
https://refspecs.linuxbase.org/elf/gabi4+/ch5.pheader.html
https://refspecs.linuxbase.org/elf/gabi4+/ch5.dynamic.html#dynamic_section

### Readelf internals

### LIEF internals

### How everything comes together

## TLDR ?

## Final word