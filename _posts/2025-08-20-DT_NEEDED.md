---
title: I DT_NEEDED HELP !
description: >-
  This blog post will explain what I've learned about ELF dynamic entries and how they may be obfuscated on Android.
author: klcium
date: 2025-07-20 20:55:00 +0800
categories: [Reverse Engineering]
tags: [ELF, Reverse]
pin: false
published: true
---

## Introduction
Last winter, I wanted to hook into an Android application for a project at work. The primary objective was to bypass the anti-hooking techniques and intercept the data exchanged between a drone and its controlling application prior to a firmware analysis. Long story short, after multiple unsuccessful attempts I set this project aside but it never really left my mind.

Fast forward 10 months later, I came across an article that I missed from [Nozomi Networks Labs](https://www.nozominetworks.com/blog/dji-mavic-3-drone-research-part-1-firmware-analysis). 

Not only did this article surprise me—it had already done all the research more than a year earlier—but it also managed to hook the packing library and dump the DEX files using the exact same techniques I had tried.

This blog is a retro-analysis on how they did it and what I missed during my initial attempts.

## Presentation of the Problem
### Prior work
The DJI Fly ("dji.go.v5") should not be misunconfused with the DJI Pilot application. The latter — specifically its packing mechanisms — has already been reverse engineered multiple times by both [Synacktiv](https://www.synacktiv.com/publications/dji-pilot-android-application-security-analysis-0.html) and [Quarkslab](https://blog.quarkslab.com/). I highly recommend that you read Eric Le Guevel's  article [the ART of obfuscation](https://blog.quarkslab.com/dji-the-art-of-obfuscation.html) on which I based my research.

From what I have read, the DJI Pilot APK is protected by the SecNeo/BangCle wrapper and its protection scheme consists in splitting the classes in multiple encrypted DEX files.

Dumping the DEX files dynamically seemed pretty straightforward: Hook the decryption function `decrypt_jar_128K` from the `libDexHelper.so` native library and dump the memory. A less trivial approach would consist in reversing the encryption mechanisms and rebuild the DEX files locally.

> Note: in DJI Fly, past 1.12 ~ 1.13 the libDexHelper.so app is renamed libAppGuard.so. But it is the same thing, actually.


Since both apps are packed by SecNeo (I think), all I have to do was to reproduce theses steps. **Easy ..right?**

![pic not related](/assets/img/shitpost/kittens/cat_squeeshy.gif)

*(Pic not related)*

Well **obviously not**, otherwise this article wouldn't exist.

- First of all, the `decrypt_jar_128K` method does not exist in DJI Fly.
- Secondly, the DJI Fly unpacking lib comes with some heavily obfuscated anti-frida techniques. 

From a static (and painful) analysis, I believe that the anti-frida code is triggered before the DEX classes are finalized. So I spent a lot of time studying what were the anti-frida techniques and how to bypass them.

### Attempts and Failures
Among the existing methods, I tried to inject a `frida-gadget` into the unpacking binary. For that, I used [LIEF](https://lief.re/), more specifically their own [tutorial](https://lief.re/doc/stable/tutorials/09_frida_lief.html) to inject a frida gadget into a native lib. 

This technique did not work, and the app no longer booted. To ensure this was not due to the injected gadget, I simply read and saved the program using LIEF—without editing the PT_DYNAMIC table (I will explain this concept further down in this article)—and got the same results.

Is displayed below the PT_DYNAMIC table of the `libAppGuard.so` file *before* injection (*Note: i trimmed the 16 bytes tags into 8 for readability*):

```bash
➜ readelf -d libAppGuard.so 
readelf: Error: no .dynamic section in the dynamic segment

Dynamic section at offset 0xefb90 contains 8 entries:
  Tag       Type                 Name/Value
 0x00000001 (NEEDED)             0xcd15
 0x00000001 (NEEDED)             0xcd23
 0x00000001 (NEEDED)             0xcd2d
 0x00000001 (NEEDED)             0xcd35
 0x00000001 (NEEDED)             0xecc7
 0x00000001 (NEEDED)             0xecd0
 0x0000000e (SONAME)             0xed0d
 0x00000000 (NULL)               0x0
```

And after injection:
```bash
➜ readelf -d libAppGuard.so.out
readelf: Warning: Section 0 has an out of range sh_link value of 118202
readelf: Error: no .dynamic section in the dynamic segment

Dynamic section at offset 0xefb90 contains 33 entries:
  Tag       Type                 Name/Value
 0x00000001 (NEEDED)             Shared library: [libapagnan.so]
 0x00000001 (NEEDED)             Shared library: [libandroid.so]
 0x00000001 (NEEDED)             Shared library: [liblog.so]
 0x00000001 (NEEDED)             Shared library: [libz.so]
 0x00000001 (NEEDED)             Shared library: [libm.so]
 0x00000001 (NEEDED)             Shared library: [libdl.so]
 0x00000001 (NEEDED)             Shared library: [libc.so]
 0x0000000e (SONAME)             Library soname: [libAppGuard.so]
 0x00000019 (INIT_ARRAY)         0xe5240
 0x0000001b (INIT_ARRAYSZ)       8 (bytes)
 0x0000001a (FINI_ARRAY)         0xe5248
 0x0000001c (FINI_ARRAYSZ)       16 (bytes)
 0x00000004 (HASH)               0x228
 0x6ffffef5 (GNU_HASH)           0x29f8
 0x00000005 (STRTAB)             0xe098
 0x00000006 (SYMTAB)             0x52a8
 0x0000000a (STRSZ)              60705 (bytes)
 0x0000000b (SYMENT)             24 (bytes)
 0x00000003 (PLTGOT)             0xe8950
 0x00000002 (PLTRELSZ)           14352 (bytes)
 0x00000014 (PLTREL)             RELA
 0x00000017 (JMPREL)             0x27888
 0x00000007 (RELA)               0x1d9d0
 0x00000008 (RELASZ)             40632 (bytes)
 0x00000009 (RELAENT)            24 (bytes)
 0x0000001e (FLAGS)              BIND_NOW
 0x6ffffffb (FLAGS_1)            Flags: NOW
 0x6ffffffe (VERNEED)            0x1d990
 0x6fffffff (VERNEEDNUM)         2
 0x6ffffff0 (VERSYM)             0x1cdba
 0x6ffffff9 (RELACOUNT)          1093
 0x0000000c (INIT)               0x108098
 0x00000000 (NULL)               0x0
```

Finally here is what you may see if you open the binary with Ghidra to check manually its contents:

![ghidra DT_NEEDED](/assets/img/posts/2025-08-20-DT_NEEDED/ghidra_appguard_injected_PT_DYNAMIC.png)

## Many Questions

If you pay attention to these results, you may be asking yourself: 
- Why can't `readelf` find the `.dynamic` section?  
- After injection, why does `Ghidra` show 6 `DT_NEEDED` tags but `readelf` shows 7 ?  
- Why does `readelf` show integers instead of names before the injection, but not after?  
- Why does `Ghidra` show incorrect lib names after the injection, but not before?  (not shown in the screenshots)
- In `readelf` after injection, where do all these new dynamic entries come from?  

> If you can answer all of these questions, congrats.

I eventually gave up and might come back to it later once I get more skilled at reverse engineering (RE). To be fair, progress was slow, and spending more time trying to understand this wasn’t a priority.

> Btw, I do consider myself a rookie. There are certainly a lot of mistakes and imprecisions in this article.

### Turning point
After a lot of failed attempts, I eventually set this project aside to focus on some other projects. Blatantly aware of my incompetence, the idea was to come back to it once I'd be skilled enough to crack it. And that's how it went until I found this blogpost from [Nozomi Networks Labs](https://www.nozominetworks.com/blog/dji-mavic-3-drone-research-part-1-firmware-analysis). Not only did they managed to hook and dump the DEX files, but **they did it using the exact same\* method I had tried**.

> "We dump the decrypted .DEX files by reading the raw memory layout of the application from /proc/self/maps through a code injection, exploiting DT_NEEDED entries with LIEF from QuarksLab, and inspecting it to extract the unpacked data."

> \* Actually ☝️🤓, they used the same technique but did not injected any `frida-agent` (from what I've understood).

![you did it crazy soab](/assets/img/shitpost/you-crazy-son-of-a-bitch-you-did-it-meme.png)

Unfortunately, their article does not provide more information on how they achieved it. But at least now, I have proof of the feasibility of this technique, and all I have to do now is *try harder™*.

## Anatomy of a Fail
So, what did I miss? If you want the short answer, jump straight to the conclusion. Otherwise, stay with me as I will first explain the concepts required to fully understand the answer.

### The ELF File Format

#### ELF Structure
In Linux, at the beginning of each executable, there is an ELF (*Extensible Linking Format*) file structure that starts with `7F 45 4c 46` or `0x7F ELF`.

In the ELF structure you may find information regarding the segments and sections tables. 

> A segment is the logical representation of a file in memory. A program header is an entry that describes a segment. You will often see these words used interchangeably.

The ELF structure is described below. I won't go into much detail as it's already well documented [online](https://refspecs.linuxbase.org/elf/gabi4+/ch4.eheader.html).
```c
typedef struct {
        unsigned char   e_ident[EI_NIDENT];
        Elf64_Half      e_type;
        Elf64_Half      e_machine;
        Elf64_Word      e_version;
        Elf64_Addr      e_entry; <- Entry point
        Elf64_Off       e_phoff; <- offset of PH
        Elf64_Off       e_shoff; <- offset of SH
        Elf64_Word      e_flags; 
        Elf64_Half      e_ehsize;
        Elf64_Half      e_phentsize; <- size of a PH entry
        Elf64_Half      e_phnum; <- number of PH entries
        Elf64_Half      e_shentsize; <- size of a SH entry
        Elf64_Half      e_shnum; <- number of SH entries
        Elf64_Half      e_shstrndx;
} Elf64_Ehdr;
```

At this point, remember that this structure describes the `offset`, `size` and `number` of entries of the segment `ELF64_Phdr[]` and section `Elf64_Shdr[]` tables and that these information are processed by the linker when loading the ELF file.

We will now clarify what are segments and sections.

#### Segments 

**[Program headers](https://refspecs.linuxbase.org/elf/gabi4+/ch5.pheader.html) (segments)** describe how the operating system should load and map parts of an executable into memory. 

⚠️ Segments are required for the binary to run.

```c
typedef struct {
	Elf64_Word	p_type; <- Type of the Program Header
	Elf64_Word	p_flags;
	Elf64_Off	p_offset; <- Offset in the file
	Elf64_Addr	p_vaddr; <- Address in memory
	Elf64_Addr	p_paddr; 
	Elf64_Xword	p_filesz;
	Elf64_Xword	p_memsz;
	Elf64_Xword	p_align;
} Elf64_Phdr;
```

**The Dynamic Segment:**  
In the program header table, there should be exactly one entry of type `PT_DYNAMIC`. 
This entry is used by the linker to find the position of the dynamic table as pointed by the `p_vaddr` attribute.

#### Sections
**[Sections](https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html)** define the logical organization of the executable’s contents, like code, data, or symbols, for the linker and loader. Sections provide useful data for static analysis or debugging.

⚠️ Sections are *usually* not required for runtime.

As a result, a program only needs the segments to be valid in order to be executed properly.  Sections can be stripped from the file or deliberately corrupted to complicate reverse engineering..

```c
typedef struct {
	Elf64_Word	sh_name;
	Elf64_Word	sh_type;
	Elf64_Xword	sh_flags;
	Elf64_Addr	sh_addr;
	Elf64_Off	sh_offset;
	Elf64_Xword	sh_size;
	Elf64_Word	sh_link;
	Elf64_Word	sh_info;
	Elf64_Xword	sh_addralign;
	Elf64_Xword	sh_entsize;
} Elf64_Shdr;
```


**The Dynamic Section:**  (aka The Dynamic Table)  
The **[dynamic section](https://refspecs.linuxbase.org/elf/gabi4+/ch5.dynamic.html#dynamic_section)** **is** the dynamic table.  
The dynamic section **must** be pointed by the `PT_DYNAMIC` header of the process header table.  
The dynamic section **can** be pointed by the `SHT_DYNAMIC` entry of the section table.  
> Actually ☝️🤓,  `.dynamic` is the canonical name of the ELF section that holds the dynamic table. `SHT_DYNAMIC` is the type of `.dynamic` section. The same goes for the `PT_DYNAMIC` which is the type of the dynamic segment. 

In other words, both the dynamic section and the dynamic segment *should* reference the same table. But you must not trust the section table.

**The dynamic table in itself** is a data structure used to manage the dynamic linking of a binary file upon loading.

It contains useful information such as (but not limited to):
- The entry point that gets executed before the actual entry of a binary.
- The list of dependencies that must be loaded before the binary is run. 

> In our case, we want to add a dependency (that we control) in the dynamic table in order to inject code as the target application.

The structure of a dynamic table entry is shown below:
```c
typedef struct {
  Elf64_Sxword d_tag;   // type (DT_NEEDED, DT_INIT, etc.)
  union {
    Elf64_Xword d_val;
    Elf64_Addr  d_ptr;
  } d_un;
} Elf64_Dyn;
```

In order to know which entry corresponds to what, `Dynamic Array Tags` or `d_tags`. Some entry with specific tags are required, some are optional.

Is presented below the extract of only the `required` entries in a dynamic table of a shared object :  

|Name|Value|d_un|Executable|Shared Object|
|----|----|----|----|----|
|DT_NULL|0|ignored|mandatory|mandatory|
|DT_NEEDED|1|d_val|optional|optional|
|DT_HASH|4|d_ptr|mandatory|mandatory|
|DT_STRTAB|5|d_ptr|mandatory|mandatory|
|DT_SYMTAB|6|d_ptr|mandatory|mandatory|
|DT_STRSZ|10|d_val|mandatory|mandatory|
|DT_SYMENT|11|d_val|mandatory|mandatory|

Notice that I left one optionnal entry: `DT_NEEDED`  
An entry of this type 

If you are interested to know more about this topic, I recommend you [this reading](https://refspecs.linuxbase.org/elf/gabi4+/ch5.dynamic.html).


#### Overall representation

To help you figure out how this works, here is a representation of what a common binary **should** look like on disk and in memory. You may observe the program headers, segments, section  headers and sections and which points to what.

![segment_sections_diagram](/assets/img/posts/2025-08-20-DT_NEEDED/default_view_elf_pt.png)

As you can see, both `SHT_DYNAMIC` and `PT_DYNAMIC` entries point to the `.dynamic` section which holds the dynamic table.
Notice that the `PT_DYNAMIC` entry points to the table once on disk (`p_offset`) and once in memory (`p_vaddr`).


### Loading and Linking Processes

When you double click on an ELF file, the program does not magically appear in memory, ready to run. The Linux kernel is responsible for handling your request, loading the process into memory, and preparing it to run.

To understand how the Kernel launches a process, read this https://lwn.net/Articles/631631/.

> We will go into the relevant ELF Structure details soon. Don’t worry if everything isn’t clear yet. 

Here is a (very simplified) TLDR:  
1. The loader will parse the Program Header Table (PHT) for `PT_LOAD` entries and use them to map the program in memory.
2. The linker will also parse the program header to find the `PT_DYNAMIC` entry. 
3. The linker then reads the entry `p_vaddr` to find the virtual address of the Dynamic Table.
4. The linker does [more stuff](https://lwn.net/Articles/961117/) we won't talk about here



### Readelf Internals
As the good IT engineer you are, you did read the man page of the `readelf` program. Right?
```
 -d
 --dynamic
     Displays the contents of the file's dynamic section, if it has one.
``` 
Hm, that's interesting. Since sections should not be trusted, why doesn't the program search for the `PT_DYNAMIC` instead? The answer is obviously more nuanced than this.  
The next chapter will walk you through how `readelf` finds and parses the dynamic table.

#### How does readelf find the dynamic table?  
Here is how the function `process_program_headers()` finds the dynamic table:  
1. **Sets** the address of the dynamic section by reading `p_offset` of the `PT_DYNAMIC` entry.
2. If there is a `.dynamic` section, it **replaces** the address of the dynamic section by the value of the `sh_offset` attribute of the `SHT_DYNAMIC` entry.  

You may find below the [source code](https://github.com/bminor/binutils-gdb/blob/master/binutils/readelf.c#L7274) of the "process_program_headers" of the readelf executable.

```c
static void process_program_headers(Filedata * filedata)
{
  Elf_Internal_Phdr * segment;
  //[some code]
  for (i = 0, segment = filedata->program_headers;
      i < filedata->file_header.e_phnum;
      i++, segment++)
  {
    if (do_segments){
      switch (segment->p_type)
      {
        //[SOME CODE]
        case PT_DYNAMIC:
          if (dynamic_addr){
            error (_("more than one dynamic segment\n"));

          /* By default, assume that the .dynamic section is the first
            section in the DYNAMIC segment.  */
          dynamic_addr = segment->p_offset;
          dynamic_size = segment->p_filesz;

          /* Try to locate the .dynamic section. If there is
            a section header table, we can easily locate it.  */
          if (filedata->section_headers != NULL)
            {
              Elf_Internal_Shdr * sec;

              sec = find_section (filedata, ".dynamic");
              if (sec == NULL || sec->sh_size == 0)
          {
            /* A corresponding .dynamic section is expected, but on
              IA-64/OpenVMS it is OK for it to be missing.  */
            if (!is_ia64_vms (filedata))
              error (_("no .dynamic section in the dynamic segment\n"));
            break;
          }
              dynamic_addr = sec->sh_offset;
              dynamic_size = sec->sh_size;
              /* The PT_DYNAMIC segment, which is used by the run-time
          loader,  should exactly match the .dynamic section.  */
              if (do_checks
            && (dynamic_addr != segment->p_offset
                || dynamic_size != segment->p_filesz))
          warn (_("the .dynamic section is not the same as the dynamic segment\n"));
          }
        break;
          }
        }
      }
    }
}

```

#### How does readelf finds sections?  
It's as simple as looping through the sections and checking the name.

```c
static Elf_Internal_Shdr *find_section (Filedata * filedata, const char * name)
{
  unsigned int i;

  if (filedata->section_headers == NULL)
    return NULL;
  // Loops through section headers
  for (i = 0; i < filedata->file_header.e_shnum; i++)
    // If the section name is valid
    // then compare the string
    if (section_name_valid (filedata, filedata->section_headers + i)
	&& streq (section_name (filedata, filedata->section_headers + i),
		  name))
      return filedata->section_headers + i;

  return NULL;
}
```

You may also notice the reason for the `no .dynamic section in the dynamic segment` error message that we had in the previous chapter. It loops through the `sh_name` field of each section entry, which is an offset into the String Table. Since `sh_name` is null in all of our section entries, `readelf` cannot find it.

Here is a schema to help you understand:  
![readelf_parsing_dt](/assets/img/posts/2025-08-20-DT_NEEDED/readelfparsing.png)  

> To find the string table, readelf will loop through the entries of the dynamic tablef or an entry of type `DT_STRTAB`.



### LIEF internals
For now, forget about the injection thing. The goal here is to understand how the tool finds and parse the dynamic table and then, how it re-builds the file for saving.

#### ELF File parsing process
In this sub-chapter we will see how LIEF finds the Dynamic and String tables.  
Luckily for us the code is well commented:

```cpp
template<class ELF_T>
ok_error_t Parser::parse_dyn_table(Segment& pt_dyn) {
  // Parse the dynamic table. To process this table, we can either process
  // the content of the PT_DYNAMIC segment or process the content of the PT_LOAD
  // segment that wraps the dynamic table. The second approach should be
  // preferred since it uses a more accurate representation.
  // (c.f. samples `issue_dynamic_table.elf` provided by @lebr0nli)
...
  const uint64_t dyn_start = pt_dyn.virtual_address();
  const uint64_t dyn_end = dyn_start + pt_dyn.virtual_size();
  const uint64_t load_start = segment->virtual_address();
  const uint64_t load_end = load_start + segment->virtual_size();
```
The `p_vaddr` attribute of the `PT_DYNAMIC` segment entry is used to find the dynamic table.
LIEF even goes further than this as **they also compute the relative offset of the dynamic table** based on the `PT_LOAD` segment entry that contains the dynamic table ([source](https://github.com/lief-project/LIEF/blob/abcf929efb748c7846dd59007cbb807e108db311/src/ELF/Parser.tcc#L233)).

> Note: If no wrapping `PT_LOAD` segment entry is found, the parser falls back to reading directly from the file offset of the `PT_DYNAMIC` segment entry.


## Solving Problems

### Double Dynamic Table

Let's compare the `SHT_DYNAMIC` section header entry with the `PT_DYNAMIC` program header entry:
```
PT_DYNAMIC
 - p_vaddr = 0xE8720
 - p_offset = 0xEFB90

SHT_DYN:
 - sh_addr = 0xEFB90
 - sh_offset = 0xEFB90
```
We observe that our dynamic table should be `0xEFB90` in our file and `0xE8720` in memory. But we also know (actually, I'm telling it to you right now) that the `PT_LOAD` program header are not mapping `0xEFB90` in memory...  
We also know that `0xE8720` belongs to the second `PT_LOAD` segment that is mapped in memory with no particular offset. In other terms, what is at `0xE8720` in memory should be the same data that is at the offset `0xE8720` in our file.

Let's do a double hexdump at the offset of the two tables. 

> The left part of the array corresponds to the type of the entry. The right part of the array is name of the entry referenced by an index in the string table.

If we open the file at `0xEFB90` we get:
```
➜  hexdump -C -s 0xEFB90 ./libAppGuard.so -v | head
000efb90  01 00 00 00 00 00 00 00  15 cd 00 00 00 00 00 00  |................|
000efba0  01 00 00 00 00 00 00 00  23 cd 00 00 00 00 00 00  |........#.......|
000efbb0  01 00 00 00 00 00 00 00  2d cd 00 00 00 00 00 00  |........-.......|
000efbc0  01 00 00 00 00 00 00 00  35 cd 00 00 00 00 00 00  |........5.......|
000efbd0  01 00 00 00 00 00 00 00  c7 ec 00 00 00 00 00 00  |................|
000efbe0  01 00 00 00 00 00 00 00  d0 ec 00 00 00 00 00 00  |................|
000efbf0  0e 00 00 00 00 00 00 00  0d ed 00 00 00 00 00 00  |................|
000efc00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000efc10  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000efc20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

```

If we open the file at `0xE8720` we get:
```
➜ hexdump -C -s 0xE8720 ./libAppGuard.so | head
000e8720  01 00 00 00 00 00 00 00  15 cd 00 00 00 00 00 00  |................|
000e8730  01 00 00 00 00 00 00 00  23 cd 00 00 00 00 00 00  |........#.......|
000e8740  01 00 00 00 00 00 00 00  2d cd 00 00 00 00 00 00  |........-.......|
000e8750  01 00 00 00 00 00 00 00  35 cd 00 00 00 00 00 00  |........5.......|
000e8760  01 00 00 00 00 00 00 00  c7 ec 00 00 00 00 00 00  |................|
000e8770  01 00 00 00 00 00 00 00  d0 ec 00 00 00 00 00 00  |................|
000e8780  0e 00 00 00 00 00 00 00  0d ed 00 00 00 00 00 00  |................|
000e8790  19 00 00 00 00 00 00 00  40 52 0e 00 00 00 00 00  |........@R......|
000e87a0  1b 00 00 00 00 00 00 00  08 00 00 00 00 00 00 00  |................|
000e87b0  1a 00 00 00 00 00 00 00  48 52 0e 00 00 00 00 00  |........HR......|

```
There are two dynamic tables! 
![spiderman shitpost](/assets/img/posts/2025-08-20-DT_NEEDED/spiderman_dynamic_tables.png)  
The first 7 entries are identical, but the second one has some more entries following.

To help you understand the situation, I made an other schema of what our binary looks like on disk and in memory:
![lib_rpz_in_disk_and_mem](/assets/img/posts/2025-08-20-DT_NEEDED/lib_repz.png)

> Notice how the dynamic table in the `.dynamic` section does not have any entry that points to the `.strtab`. Explaining why readelf can't resolve the strings in the table. 

So which one should we trust?

### Choosing the right table
Since Sections should not be trusted and that `PT_DYNAMIC` is not used to map the file in memory. We can guess that `p_offset` (thus `0xEFB90`) should be disregarded and `p_vaddr = 0x0E8720` should therefore be the *true* dynamic table is*.

> *Because the parent `PT_LOAD` segment does not have any offset between the file offset and virtual addresses.

By editing the file and replacing the values of `sh_addr`, `sh_offset` and `p_offset` by `0xE8720`, readelf can now correctly parse them !

```
➜  readelf -d libAppGuard_1E8720.so 
readelf: Error: no .dynamic section in the dynamic segment

Dynamic section at offset 0xe8720 contains 32 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libandroid.so]
 0x0000000000000001 (NEEDED)             Shared library: [liblog.so]
 0x0000000000000001 (NEEDED)             Shared library: [libz.so]
 0x0000000000000001 (NEEDED)             Shared library: [libm.so]
 0x0000000000000001 (NEEDED)             Shared library: [libdl.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so]
 0x000000000000000e (SONAME)             Library soname: [libAppGuard.so]
 [Some more stuff]
```


![cat dance](/assets/img/shitpost/kittens/povjisoo_cat_dance.gif)  
Yippee dance ! But we're not done yet.

> One more important thing that is not shown above: the `0xEFB90` (`p_offset`) table is outside of the `PT_LOAD` ranges: **it is not loaded in memory**.

Before injecting an lib (which may be blocked by some file integrity checks) using lief, I tried to change the offset of a `DT_NEEDED` entry for a random string included in the binary. So i naturally edited the `.unknown_section` table and ended up with NO error upon loading.  

After this and from a clean binary, I did the same operation on the `.dynamic` table and did get an error message saying the library does not exists:
 
```log
08-30 23:07:22.897 14646 14646 E AndroidRuntime: java.lang.UnsatisfiedLinkError: dlopen failed: library "_ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm" not found: needed by /data/app/~~BP8uhydRMFp4NLuTHFofag==/dji.go.v5-aI75Kdn-FZIpSKTC8MxLiA==/lib/arm64/libAppGuard.so in namespace classloader-namespace
```

So you're saying both dynamic tables are actually used to link our binary ?

![cat crying](/assets/img/shitpost/kittens/cat_crying_shake.gif)  

Yes 🥺👉👈.  
To understand why, let's look at the source code of the Android linker.


### Android library loading process

> This is my understanding of the loading process in Android, not the truth.  

When you run `System.LoadLibrary()` it executes the following chain of calls: `native_loader.OpenNativeLibrary() -> dlopen() -> __loader_dlopen() -> dlopen_ext() -> do_dlopen() -> find_library() -> find_libraries()`

The [find_libraries()](https://cs.android.com/android/platform/superproject/+/android-latest-release:bionic/linker/linker.cpp;drc=7ea4c99263fb09c4590135e78bc26fa4e5786083;l=1545) function from the bionic linker works works as follows:

**1. LOADING PHASE**  
ELF files are mapped into memory and dependencies are discovered. 
- Starts with the root library you’re opening (do_dlopen target, or main executable).
- Creates a load task queue (`load_tasks`), one per `DT_NEEDED` library.
- Each `task` is an `ElfReader` wrapper that knows how to `mmap` the file, parse headers, and extract dynamic section info.
- Calls [load_library()](https://cs.android.com/android/platform/superproject/+/android-latest-release:bionic/linker/linker.cpp;drc=7ea4c99263fb09c4590135e78bc26fa4e5786083;l=1311)
  - Opens the .so file.
  - Uses `ElfReader`:
    - [ElfReader::Read()](https://cs.android.com/android/platform/superproject/+/android-latest-release:bionic/linker/linker_phdr.cpp;drc=463df1ae532f16c29e7f57ac85ec519004b7a8ff;l=166) parses ELF headers, finds `PT_LOAD` segments, [parses PT_DYNAMIC](https://cs.android.com/android/platform/superproject/+/android-latest-release:bionic/linker/linker_phdr.cpp;drc=463df1ae532f16c29e7f57ac85ec519004b7a8ff;l=375), etc.
    > ⚠️ It parses the `SHT_DYNAMIC` value, which **must** be equal to the **p_offset** and have the **same size** as in the program header.  
    The `SHT_STRTAB` is found via `dynamic_shdr->sh_link` which is the index of the `SHT_STRTAB` entry in the `SHT`.
    - mmaps the segments into memory.
    - Sets pointers to dynamic_ (from `SHT_DYNAMIC`) and strtab (from `DT_STRTAB` entry).
    > Later the linker will call the getter [ElfReader::Dynamic()](https://cs.android.com/android/platform/superproject/+/android-latest-release:bionic/linker/linker.cpp;drc=7ea4c99263fb09c4590135e78bc26fa4e5786083;l=1299) to get this data.
  - While [parsing the dynamic section](https://cs.android.com/android/platform/superproject/+/android-latest-release:bionic/linker/linker.cpp;drc=7ea4c99263fb09c4590135e78bc26fa4e5786083;l=1304):
    - Collects `DT_NEEDED` entries (library names in .dynstr).
    - For each, adds another task to the same load queue.


**2. LINKING PHASE**
- [prelink_image()](https://cs.android.com/android/platform/superproject/+/android-latest-release:bionic/linker/linker.cpp;drc=7ea4c99263fb09c4590135e78bc26fa4e5786083;l=2852):
  - Processes relocations like `DT_HASH`, `DT_GNU_HASH`, `DT_INIT_ARRAY` based on the `p_vaddr` value of the `PT_DYNAMIC` segment !
  - Also sets up `soinfo->strtab`, `soinfo->symtab`, `soinfo->plt_got`, etc. based on the `PT_DYNAMIC` dynamic table.
  > ⚠️ The entries `DT_HASH`/`DT_GNU_HASH`, `DT_SYMTAB` and `DT_STRTAB` are actually required in the `PT_DYNAMIC` DT for the lib to be loaded.
- Calls into `soinfo->link_image()` which actually does the linking job.

### Injecting the binary

> I am still working on this. @NozomiNetworks plz help me 🥺👉👈

## Answers

**In `readelf` after injection, where do all these new dynamic entries come from?**  
LIEF parsed the correct dynamic entry. Upon modification it wrote the `p_vaddr` dynamic at the position of the `p_offset` of the `PT_DYNAMIC` entry.
The two dynamic tables have a different size. The `p_vaddr` one was larger and overflowed into the section header table.

![](/assets/img/posts/2025-08-20-DT_NEEDED/before_after_lief.png)

**After injection, why does `Ghidra` show 6 `DT_NEEDED` tags but `readelf` show 7**  
Because `Ghidra` uses the `p_vaddr` of the `PT_DYNAMIC` entry to find the dynamic table whereas `readelf` uses the `p_offset` of the same structure. 
In our case, these values are different. 

In the capture of the previous answer, in the "On Disk After Injection" table, `Ghidra` will read the non injected `.unknown_section`, whereas `readelf` will read the injected `.unknown_section` which is now referencing a string table.

**Why does `readelf` show integers instead of names before the injection, but not after?**  
Because `readelf` loops through the segments to find the dynamic table (then sections, but not in our case). It finds the `p_offset` Dynamic Table which has no `DT_STRTAB` entry, thus fails to find the corresponding strings.

**Why does `Ghidra` show incorrect library names after the injection, but not before?**  
Because `Ghidra` uses the dynamic table at the `p_vaddr` attribute of the `PT_DYNAMIC` entry. But LIEF wrote the injected dynamic table at the position of the `p_offset` one. In the process it changed the order of the entries in the string tables which led to incorrect string readings.

Here are two diagrams explaining the dynamic tables before and after injecting with LIEF.
The first table is parsesd by LIEF, the second by `Ghidra`.

Before injection:  
![before_lief](/assets/img/posts/2025-08-20-DT_NEEDED/before_lief.png)

After injection:  
![after_lief](/assets/img/posts/2025-08-20-DT_NEEDED/after_lief.png)


**Why can't `readelf` find the `.dynamic` section?**  
Because it searches for the section headers with the name `.dynamic`. In our case, all section names are stripped. It will therefore fallback the `.dynamic` section using the program headers.


## Restrospective
Simply *knowing* how the ELF format works is not enough when getting confronted with some actual obfuscated binaries. A deep understanding of how ELF files are parsed by various Linux processes is also important.

Actually you may achieve the same results with lief without patching the binary prior to injection. I did miss the invalid section size issue in the `adb logcat` output that also occurs when injecting the original binary.

The linker requires the `p_offset` of the `PT_DYNAMIC` to match the `sh_offset` of the `SHT_DYNAMIC`. Hence why there are two different values in the `PT_DYNAMIC` ([source](https://android.googlesource.com/platform/bionic/+/master/android-changes-for-ndk-developers.md#missing-section-headers-enforced-for-api-level-24)).

`readelf` reads the sections table to find the dynamic table. If the `.dynamic` section is not found, it **assumes** that it is where `PT_DYNAMIC` points to.

`DT_NEEDED` entries are parsed from the sections (kind of) ! In Android, the `.dynamic` section entry must have the same offset and size of the `PT_DYNAMIC` `p_offset` entry. A `DT_STRTAB` is not required as it is found via the `sh_link` attribute of the `SHT_DYNAMIC`.

## More reading
- https://www.virusbulletin.com/uploads/pdf/conference/vb2024/papers/Detecting-Shared-Object-injection.pdf 
- https://zhenhuaw.me/blog/2016/android-dynamic-linker.html  
