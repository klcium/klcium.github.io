---
title: DT_NEEDED HELP !
description: >-
  This blogpost will explain some protection techniques against modification of dynamic program header entries.
author: klcium
date: 2025-07-20 20:55:00 +0800
categories: [Reverse Engineering]
tags: [ELF, Reverse]
pin: false
published: true
---

## Introduction
Last winter, I wanted hook some Android application for a project at work.The primary objective was to bypass the anti-hooking techniques and intercept the exchanged data between a DJI drone and its controlling application prior to a firmware analysis. Long story short, after multiple unsuccessful attempts I left this project on the side but it never really left my mind.
Cracking a program open is like solving a puzzle. There is always a solution, finding it is always a matter of time and efforts. 

Fast forward 10 months later, I came accross an article that I missed from [Nozomi Networks Labs](https://www.nozominetworks.com/blog/dji-mavic-3-drone-research-part-1-firmware-analysis). 

Not only this article surprised me as they already did all the research work more than a year earlier, but they also managed to hook the packing lib and dump the dex files using the exact same techniques that I tried 10 months earlier.

This blog is a retro-analysis on how they did it and what I missed during my initial attempts.

## Presentation of the Problem
### Prior work
The DJI Fly ("dji.go.v5") should not be misunderstood with the DJI Pilot application. The latter, (more specifically its packing mechanisms) has already been reverse engineered multiple times by both [Synacktiv](https://www.synacktiv.com/publications/dji-pilot-android-application-security-analysis-0.html) and [Quarkslab](https://blog.quarkslab.com/). I highly recommend you to read Eric Le Guevel's  article [the ART of obfuscation](https://blog.quarkslab.com/dji-the-art-of-obfuscation.html) on which I based my research.

From what I have read, the DJI Pilot is protected by the SecNeo/BangCle wrapper and its protection scheme consists in splitting the classes in multiple encrypted dex files.

Dumping the dex files dynamically seemed pretty "easy": Hook the decrypting function `decrypt_jar_128K` from the `libDexHelper.so` native lib and dump the memory. A less trivial approach would consist in reversing the encryption mechanisms and rebuild the dex files locally.

> Note: in DJI Fly, past 1.12 ~ 1.13 the libDexHelper.so app is renamed libAppGuard.so. But it is the same thing actually.


Since both apps are packed by SecNeo, all I have to do is to reproduce theses steps. **Easy ..right?**

![pic not related](/assets/img/shitpost/kittens/cat_squeeshy.gif)

*(Pic not related)*

Well **obviously not**, otherwise this article wouldn't exist.

- First of all, the `decrypt_jar_128K` method does not exist in DJI Fly.
- Secondly, the DJI Fly unpacking lib comes with some heavily obfuscated anti-frida techniques. 

From a static (and painful) analysis, I believe that the anti-frida code is triggered before the dex classes are finalized. So I spent a lot of time studying what were the anti-frida techniques and how to bypass them.

### Attempts and Failures
Amongst the existing methods, I tried to inject a frida-gadget into the unpacking binary. For that, I used [LIEF](https://lief.re/), more specifically their own [tutorial](https://lief.re/doc/stable/tutorials/09_frida_lief.html) to inject a frida gadget into a native lib. 

This technique did not work and the app was no longer booting. To make sure this was not due to the injected gadget, I simply read and save the program usingn LIEF without editing the PT_DYNAMIC table (I will explain this concept further down this article) and yielded the same results.

Is displayed below the PT_DYNAMIC table of the `libAppGuard.so` file *before* injection (*Note: i trimmed the 16 bytes tags into 8 for readability*):

```bash
➜ readelf -d libAppGuard.so 
readelf: Error: no .dynamic section in the dynamic segment

Dynamic section at offset 0xefb90 contains 8 entries:
  Tag       Type                 Name/Value
 0x00000001 (NEEDED)             0xcd15
 0x00000001 (NEEDED)             0xcd23
 0x00000001 (NEEDED)             0xcd2d
 0x00000001 (NEEDED)             0xcd35
 0x00000001 (NEEDED)             0xecc7
 0x00000001 (NEEDED)             0xecd0
 0x0000000e (SONAME)             0xed0d
 0x00000000 (NULL)               0x0
```

And after injection:
```bash
➜ readelf -d libAppGuard.so.out
readelf: Warning: Section 0 has an out of range sh_link value of 118202
readelf: Error: no .dynamic section in the dynamic segment

Dynamic section at offset 0xefb90 contains 33 entries:
  Tag       Type                 Name/Value
 0x00000001 (NEEDED)             Shared library: [libapagnan.so]
 0x00000001 (NEEDED)             Shared library: [libandroid.so]
 0x00000001 (NEEDED)             Shared library: [liblog.so]
 0x00000001 (NEEDED)             Shared library: [libz.so]
 0x00000001 (NEEDED)             Shared library: [libm.so]
 0x00000001 (NEEDED)             Shared library: [libdl.so]
 0x00000001 (NEEDED)             Shared library: [libc.so]
 0x0000000e (SONAME)             Library soname: [libAppGuard.so]
 0x00000019 (INIT_ARRAY)         0xe5240
 0x0000001b (INIT_ARRAYSZ)       8 (bytes)
 0x0000001a (FINI_ARRAY)         0xe5248
 0x0000001c (FINI_ARRAYSZ)       16 (bytes)
 0x00000004 (HASH)               0x228
 0x6ffffef5 (GNU_HASH)           0x29f8
 0x00000005 (STRTAB)             0xe098
 0x00000006 (SYMTAB)             0x52a8
 0x0000000a (STRSZ)              60705 (bytes)
 0x0000000b (SYMENT)             24 (bytes)
 0x00000003 (PLTGOT)             0xe8950
 0x00000002 (PLTRELSZ)           14352 (bytes)
 0x00000014 (PLTREL)             RELA
 0x00000017 (JMPREL)             0x27888
 0x00000007 (RELA)               0x1d9d0
 0x00000008 (RELASZ)             40632 (bytes)
 0x00000009 (RELAENT)            24 (bytes)
 0x0000001e (FLAGS)              BIND_NOW
 0x6ffffffb (FLAGS_1)            Flags: NOW
 0x6ffffffe (VERNEED)            0x1d990
 0x6fffffff (VERNEEDNUM)         2
 0x6ffffff0 (VERSYM)             0x1cdba
 0x6ffffff9 (RELACOUNT)          1093
 0x0000000c (INIT)               0x108098
 0x00000000 (NULL)               0x0
```

Finally here is what you may see if you open the binary with Ghidra to check manually its contents:

![ghidra DT_NEEDED](/assets/img/posts/2025-08-20-DT_NEEDED/ghidra_appguard_injected_PT_DYNAMIC.png)

## Many Questions

If you pay attention to the results, you may be asking yourself: 
- In the injected library, why are there 6 `DT_NEEDED` tags with Ghidra but 7 with readelf ?
- Why are there integers instead of names before the injection but not after ? 
- Why `readelf` can't find the `.dynamic` section ?
- Where all these new dynamic entries come from ?
- Why am I reading this article ?

So many questions left unanswered 
And that's how I said 🌞*fuck this shit*🌞 and tried some other techniques to find.

> If you can answer all of these questions, congrats. Here is a cookie `JSESSONID=de1dc51aed38a6916826eab84347b25f`.

> To be honest, I was (and am still) a rookie. Progress was slow and spending more time to understand this was not the priority.

### Turning point
After multilpe weeks of failing, I set this project aside to focus on some other projects. The idea was to come back at it once I'd be skilled enough to crack it. But it never really left my mind.

And that's how it went until I found this blogpost from [Nozomi Networks Labs](https://www.nozominetworks.com/blog/dji-mavic-3-drone-research-part-1-firmware-analysis). 

Not only they managed to hook and dump the dex files, but **they did it using this exact same\* method that I tried**.

> "We dump the decrypted .dex files by reading the raw memory layout of the application from /proc/self/maps through a code injection, exploiting DT_NEEDED entries with LIEF from QuarksLab, and inspecting it to extract the unpacked data."

> \* Actually ☝️🤓, they used the same technique but did not injected any frida-agent (from what I've understood).

![you did it crazy soab](/assets/img/shitpost/you-crazy-son-of-a-bitch-you-did-it-meme.png)

Unfortunately, their article does not provides more information on how they achieved it. But at least, I now have a proof of the feasability of this technique and that all I have to do now is to *try harder™*.

## Anatomy of a Dail
So what did I miss ? If you want the short answer, jump straight to the conclusion. Otherwise, stay with me as I will first explain the concepts required to fully understand the answer.

### The ELF File Format

#### ELF Structure
In Linux, at the beginning of each executable, there is an ELF ( *Extensible Linking Format*) file structure that starts with `7F 45 4c 46` or `0x7F ELF`.

In the ELF structure you may find information regarding the segments and sections tables. 

> A segment is the logical representation of a file in memory. A program header is an entry that describes a segment. You will often see these words used interchangeably.

The ELF structure is described below. I won't go into much details as it's already well documented [online](https://refspecs.linuxbase.org/elf/gabi4+/ch4.eheader.html).
```c
typedef struct {
        unsigned char   e_ident[EI_NIDENT];
        Elf64_Half      e_type;
        Elf64_Half      e_machine;
        Elf64_Word      e_version;
        Elf64_Addr      e_entry; <- Entry point
        Elf64_Off       e_phoff; <- offset of PH
        Elf64_Off       e_shoff; <- offset of SH
        Elf64_Word      e_flags; 
        Elf64_Half      e_ehsize;
        Elf64_Half      e_phentsize; <- size of a PH entry
        Elf64_Half      e_phnum; <- number of PH entries
        Elf64_Half      e_shentsize; <- size of a SH entry
        Elf64_Half      e_shnum; <- number of SH entries
        Elf64_Half      e_shstrndx;
} Elf64_Ehdr;
```

At this point, remember that this structure describes the `offset`, `size` and `number` of entries of the segment `ELF64_Phdr[]` and section `Elf64_Shdr[]` tables and that these information are processed by the linker when loading the ELF file.

We will now clarify what are segments and sections.

#### Segments 

**[Program headers](https://refspecs.linuxbase.org/elf/gabi4+/ch5.pheader.html) (segments)** describe how the operating system should load and map parts of an executable into memory. 

<!> Segments are required to run the binary

```c
typedef struct {
	Elf64_Word	p_type; <- Type of the Program Header
	Elf64_Word	p_flags;
	Elf64_Off	p_offset; <- Offset in the file
	Elf64_Addr	p_vaddr; <- Address in memory
	Elf64_Addr	p_paddr; 
	Elf64_Xword	p_filesz;
	Elf64_Xword	p_memsz;
	Elf64_Xword	p_align;
} Elf64_Phdr;
```

**The Dynamic Segment:**  
In the process header table, there should be exactly one entry of type `PT_DYNAMIC`. 
This entry is used by the linker to find the position of the dynamic table as pointed by the `p_vaddr` attribute.

#### Sections
**[Sections](https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html)** define the logical organization of the executable’s contents, like code, data, or symbols, for the linker and loader. Sections are useful data for static analysis or debugging.

<!> Sections are not required for runtime

As a result, a program only needs the segments to be valid in order to be executed properly.  Sections can be stripped off the file or corrupted voluntarily to complexify reverse engineering.

```c
typedef struct {
	Elf64_Word	sh_name;
	Elf64_Word	sh_type;
	Elf64_Xword	sh_flags;
	Elf64_Addr	sh_addr;
	Elf64_Off	sh_offset;
	Elf64_Xword	sh_size;
	Elf64_Word	sh_link;
	Elf64_Word	sh_info;
	Elf64_Xword	sh_addralign;
	Elf64_Xword	sh_entsize;
} Elf64_Shdr;
```

**The Dynamic Section:**  
The **[dynamic section](https://refspecs.linuxbase.org/elf/gabi4+/ch5.dynamic.html#dynamic_section)** **is** the dynamic table.  
The dynamic section **must** be pointed by the `PT_DYNAMIC` header of the process header table.  
The dynamic section **can** be pointed by the `SHT_DYNAMIC` entry of the section table.  
> Actually ☝️🤓,  `.dynamic` is the cannonical name of the ELF section that holds the dynamic table. `SHT_DYNAMIC` is the type of `.dynamic` section. The same goes for the `PT_DYNAMIC` which is the type of the dynamic segment. 

In other words, both the dynamic section and the dynamic segment *should* refer the same table. But you must not trust the section table.

Is presented below the structure of an entry of the dynamic table:
```c
typedef struct {
  Elf64_Sxword d_tag;   // type (DT_NEEDED, DT_INIT, etc.)
  union {
    Elf64_Xword d_val;
    Elf64_Addr  d_ptr;
  } d_un;
} Elf64_Dyn;
```

### Loading and Linking Processes

When you double click on an ELF file, the program does not magically appears in memory, ready to run. The Linux kernel is responsible for answering your request and will load your process in memory and "prepare" it to run.

To understand what the Kernel launches a process, read this https://lwn.net/Articles/631631/.

> We will go into the relevant ELF Structure details soon. Don't worry if you don't understand everything yet. 

Here is a (very simplified) TLDR:  
1. The loader will parse the Program Header Table (PHT) for `PT_LOAD` entries and use them to map the program in memory.
2. The linker will also parse the program header to find the `PT_DYNAMIC` entry. 
3. The linker then reads the entry `p_vaddr` to find the virtual address of the Dynamic Table.
4. The linker does [more stuff](https://lwn.net/Articles/961117/) we won't talk about here

### Readelf Internals
As the good IT engineer you are, you did read the manpage of the `readelf` program. Right ?
```
 -d
 --dynamic
     Displays the contents of the file's dynamic section, if it has one.
``` 

#### How does readelf finds the dynamic table ?  
Here is how the function `process_program_headers` finds the dynamic table :  
1. **Sets** the address of the dynamic section by reading `p_offset` of the PT_DYNAMIC entry.
2. If there is a `.dynamic` section, it **replaces** the address the dynamic section by the value of the `sh_offset` attribute of the SHT_DYNAMIC entry.  

You may find below the [source code](https://github.com/bminor/binutils-gdb/blob/master/binutils/readelf.c#L7274) of the "process_program_headers" of the readelf executable.

```c
static void process_program_headers(Filedata * filedata)
{
  Elf_Internal_Phdr * segment;
  //[some code]
  for (i = 0, segment = filedata->program_headers;
      i < filedata->file_header.e_phnum;
      i++, segment++)
  {
    if (do_segments){
      switch (segment->p_type)
      {
        //[SOME CODE]
        case PT_DYNAMIC:
          if (dynamic_addr){
            error (_("more than one dynamic segment\n"));

          /* By default, assume that the .dynamic section is the first
            section in the DYNAMIC segment.  */
          dynamic_addr = segment->p_offset;
          dynamic_size = segment->p_filesz;

          /* Try to locate the .dynamic section. If there is
            a section header table, we can easily locate it.  */
          if (filedata->section_headers != NULL)
            {
              Elf_Internal_Shdr * sec;

              sec = find_section (filedata, ".dynamic");
              if (sec == NULL || sec->sh_size == 0)
          {
            /* A corresponding .dynamic section is expected, but on
              IA-64/OpenVMS it is OK for it to be missing.  */
            if (!is_ia64_vms (filedata))
              error (_("no .dynamic section in the dynamic segment\n"));
            break;
          }
              dynamic_addr = sec->sh_offset;
              dynamic_size = sec->sh_size;
              /* The PT_DYNAMIC segment, which is used by the run-time
          loader,  should exactly match the .dynamic section.  */
              if (do_checks
            && (dynamic_addr != segment->p_offset
                || dynamic_size != segment->p_filesz))
          warn (_("the .dynamic section is not the same as the dynamic segment\n"));
          }
        break;
          }
        }
      }
    }
}

```

#### How does readelf finds sections ?  
TODO

#### How does readelf finds the dynamic string table ?  
TODO
Here again readelf probably uses the sections or smth like that to find the offset

String table or dynamic string table ?
Talking about the sections but how does the linker finds it using PT ?
=> DT_STRTAB


### LIEF internals
TODO


At the fake table location, now is a full DT with values from the actual DT. So here is what I think it did:
- Parse the DT headers from the p_vaddr
- Write the data at the p_offset OR sh_addr of the dynamic entry.

-> TODO: look at the code or test various uses cases.

## Solving Problems

Let's compare the SHT_DYNAMIC entry with the PT_DYNAMIC entry
```
SHT_DYN:
 - sh_addr = 0xEFB90
 - sh_offset = 0xEFB90

PT_DYNAMIC
 - p_vaddr = 0xE8720
 - p_offset = 0xEFB90
```

Something is off. 
If we open the file at `0xEFB90` we get:
```
UwU
```

If we open the file at `0xE8720` we get:
```
OwO
```
Wait, we got two dynamic tables ! Which one should we trust ?
![spiderman shitpost](/assets/img/posts/2025-08-20-DT_NEEDED/spiderman_dynamic_tables.png)

What do we know so far ?
- Sections should not be trusted
- `PT_DYNAMIC` is not used to map the file in memory and that `p_offset` should be disregarded.

There is only one value that we can trust : `p_vaddr = 0xEFB90`
And this is where our *actual* 

**What if I replace the sh_addr, sh_offset and p_offset values by 0xE8720 ?**  
It's now working !!
```
➜  readelf -d libAppGuard_1E8720.so 
readelf: Error: no .dynamic section in the dynamic segment

Dynamic section at offset 0xe8720 contains 32 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libandroid.so]
 0x0000000000000001 (NEEDED)             Shared library: [liblog.so]
 0x0000000000000001 (NEEDED)             Shared library: [libz.so]
 0x0000000000000001 (NEEDED)             Shared library: [libm.so]
 0x0000000000000001 (NEEDED)             Shared library: [libdl.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so]
 0x000000000000000e (SONAME)             Library soname: [libAppGuard.so]
 [blblbla cf au dessus]
```
**[DANCING KITTY CAT]**


## Answers
maybe

**In the injected library, why are there 6 `DT_NEEDED` tags with `Ghidra` but 7 with `readelf` ?**  
Because the first uses the `p_vaddr` of the `PT_DYNAMIC` PHT entry to find the dynamic table whereas the second uses the `p_offset` of the same structure. 
In our case, theses values are different. 

**Why are there integers instead of names before the injection but not after ?** Or in other terms:  
**Why was our string table broken ?**  


## Hooking that lib
Bonus, may do it later

Todo:
- see if the file injection of the patched binary works
  - first without injecting lib
  - then injecting lib
  - check if i may need to set the section and offset back at init value due to anti tampering protections.
  - check if strtab is changed. May affect tampering protection.
- Write the script to dump the memory

## Key Takeaways

- `readelf` reads the sections table to find the dynamic table. If the `.dynamic` section is not found, it **assumes** that it is where `PT_DYNAMIC` points to.
- LIEF => **TODO**
- `Ghidra` will parse the data pointed by the `p_vaddr` attribute of the program header. 
- At runtime, the only dynamic table pointer that matters is the `p_vaddr` of the `PT_DYNAMIC` entry in the Process header table !

## Final Word

INSERT A CUTE KITTY CAT HERE