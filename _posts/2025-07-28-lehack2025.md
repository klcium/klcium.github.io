---
title: Lehack2025 - Writup Reverse
description: >-
  Writups of the reverse challenges for the WarGame CTF at LeHack 2025.
author: klcium
date: 2025-07-20 20:55:00 +0800
categories: [Blogging, Writups]
tags: [CTF, LeHack, Writups, Reverse]
pin: false
published: true
# media_subpath: '/posts/lehack2025'
---

> ⚠️ **Warning**  
> This page is still under construction

# LeHack2025 WarGame Reverse Writups.

- Easy: Hidden
- Easy: Z80 Explorer
- Medium: Singularity
- Medium: The Prodigy

Note: I like to sleep and left pretty early (midnight). I don't know if any other challenges were posted during the night. If so, please send them to me, I might add them to this writeup.

# EASY | Hidden

*Description*: Welcome to the Singularity Library! Within these digital walls lies a wealth of knowledge and hidden secrets. Your task is to navigate through the intricate data and uncover what you seek. Can you decipher the mysteries that await you?


```bash
➜  md5sum 01_hidden.bin 
2881ce64b47162dd87519be2f253de5e  01_hidden.bin

➜  file 01_hidden.bin 
01_hidden.bin: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=be185d75e898d9c8b2980317eaea848d9417d03c, for GNU/Linux 3.2.0, stripped

➜  ls -lah 01_hidden.bin
-rwxrwxr-x 1 klcium klcium 29K juin  28 22:42 01_hidden.bin

./01_hidden.bin
    
                  .__=\__                  .__==__,
                jf'      ~~=\,         _=/~'      `\,
            ._jZ'            `\q,   /=~             `\__
           j5(/                 `\./                  V\\, 
         .Z))' _____              |             .____, \)/\
        j5(K=~~     ~~~~\=_,      |      _/=~~~~'    `~~+K\\,
      .Z)\/                `~=L   |  _=/~                 t\ZL
     j5(_/.__/===========\__   ~q |j/   .__============___/\J(N,
    4L#XXXL_________________XGm, \P  .mXL_________________JXXXW8L
    ~~~~~~~~~~~~~~~~~~~~~~~~~YKWmmWmmW@~~~~~~~~~~~~~~~~~~~~~~~~~~
    
        Welcome to the Singularity Library! Will you be able 
             to find what you are looking for ?

[INFO] Loading Singularity libary
[INFO] Libary loaded!
> hello
[ERROR] Invalid password!
```

So far the binary is an ELF x86 executable which requires a password.

As it is an easy challenge the `strings` check may save us some time:
```bash
➜  strings 01_hidden.bin
/lib64/ld-linux-x86-64.so.2
_ITM_deregisterTMCloneTable
__gmon_start__
_ITM_registerTMCloneTable
dlclose
dlsym
[...]
hidden.so
check
input
[INFO] Loading Singularity libary
[ERROR] Fail to load Singularity library
[INFO] Libary loaded!
[INFO] Congratulations! You can validate with leHACK\{\%s\}
[ERROR] Invalid password!
[...]
```

From this, we observe three things:
- The password is not there
- There is a "hidden.so" shared object. Which correlates with the welcoming message.

I could not find it in the import libs. Which is peculiar. 
As shown below, a ltrace could quickly disclose that the `hidden.so` file is created in the temporary folder of the host filesystem.

From this, all we have to do is execute the original binary and copy the `/tmp/hidden.so` file before trying a password.
```bash
➜  readelf -d 01_hidden.bin          

Dynamic section at offset 0x2dd8 contains 27 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libdl.so.2]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x000000000000000c (INIT)               0x1000

➜ ltrace ./01_hidden.bin aze
getenv("LD_LIBRARY_PATH") = nil
remove("/tmp/hidden.so")  = -1
open("/tmp/hidden.so", 66, 0777)  = 3
write(3, "\177ELF\002\001\001", 14296)  = 14296
close(3)  = 0
readlink(0x7ffd9bc0b8e1, 0x7ffd9bc0b930, 4095, 0x7ffd9bc0b8f0)  s= 61
execle(0x7ffd9bc0b930, 0x7ffd9bc0b930, 0, 0x7ffd9bc0b900 <no return ...>
--- Called exec() ---
[...]
```

The flag is probably stored in the `hidden.so` shared object and exports the `check` and `input` functions:
```bash
➜  nm -D hidden.so
0000000000001160 T check
                 w __cxa_finalize@GLIBC_2.2.5
                 U fgets@GLIBC_2.2.5
                 U fwrite@GLIBC_2.2.5
                 w __gmon_start__
00000000000013a0 T input
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 U memcmp@GLIBC_2.2.5
                 U stdin@GLIBC_2.2.5
                 U stdout@GLIBC_2.2.5
                 U strchr@GLIBC_2.2.5
                 U strlen@GLIBC_2.2.5
                 U strncpy@GLIBC_2.2.5

```

When disassembling and decompiling in ghidra we find the following (very approximative and partially untrue) C code:

```c
void check(char *param_1)
{
  [...BORING STUFF...]
  strlen = ::strlen(param_1);
  strlen_ = 0x100;
  if ((int)(uint)strlen < 0x101) {
    strlen_ = (uint)strlen;
  }
  strlen = (size_t)(int)strlen_;
  __s1 = (byte *)strncpy(usr_input_bfr[0],param_1,strlen);
  if (strlen != 0) {
    strlen__ = __s1 + strlen;
    local_RAX_192 = (char *)__s1;
    do {
      while (loopchar = *local_RAX_192, loopchar == '_') {
        *local_RAX_192 = '/';
loop:
        local_RAX_192 = local_RAX_192 + 1;
        if ((byte *)local_RAX_192 == strlen__) goto exito;
      }
      if (loopchar == '/') {
        *local_RAX_192 = '_';
        goto loop;
      }
      if (loopchar == '+') {
        *local_RAX_192 = '-';
        goto loop;
      }
      if (loopchar == '-') {
        *local_RAX_192 = '+';
        goto loop;
      }
      if (loopchar == '!') {
        *local_RAX_192 = '?';
        goto loop;
      }
      if (loopchar == '?') {
        *local_RAX_192 = '!';
        goto loop;
      }
      if (loopchar == '#') {
        *local_RAX_192 = '@';
        goto loop;
      }
      if (loopchar != '@') goto loop;
      *local_RAX_192 = '#';
      local_RAX_192 = local_RAX_192 + 1;
    } while ((byte *)local_RAX_192 != strlen__);
exito:
    key = 'h';
    char_ = __s1;
    while( true ) {
      *char_ = *char_ ^ key;
      pbVar1 = char_ + (1 - (long)__s1);
      char_ = char_ + 1;
      if (char_ == strlen__) break;
      key = "hiDd3n"[(ulong)pbVar1 % 6];
    }
    if (0x1d < strlen_) {
      strlen = 0x1d;
    }
  }

  flag1[0] = '\0';
  flag1[1] = '&';
  [...MORE CHARS...]
  flag1[0x16] = '\x1c';
  flag1[0x17] = '\f';
  memcmp(__s1,flag1,strlen);
  return;
}
```

So what can we see ?
1. The user input is copies to an initialized buffer
2. Some characters are swapped: `/` with `_`, `+` with `-`, `!` with `?`, `#` with `@` and vice versa.
3. The input is then xored with `hiDd3n`
4. Flag is set in memory
5. Input compared with the flag


If you're paying attention, you will notice there's a bug in the string length verification:
The compared memory is equal to the size of the input string so you could get the flag by bruteforcing character by character.

![meme](assets/img/posts/2025-07-28-lehack2025/01_hidden_meme.png)

To solve this chall `the expected way`, I set a breakpoint in GDB and copy pasted the compared buffer. You can also get it from Ghidra but I don't like that.

```bash
 ► 0x7ffff7fb930d <check+429>    call   memcmp@plt                  <memcmp@plt>
        s1: 0x7fffffffeb60 ◂— 0x25052829                                                                     
        s2: 0x7fffffffeb40 ◂— 0x462c51574b132600                                                             
        n: 4                                                                                                 
```
```bash
pwndbg> x/100x 0x7fffffffeb40
0x7fffffffeb40: 0x00    0x26    0x13    0x4b    0x57    0x51    0x2c    0x46
0x7fffffffeb48: 0x1d    0x2b    0x46    0x41    0x2e    0x06    0x11    0x0a
0x7fffffffeb50: 0x77    0x41    0x5f    0x21    0x0d    0x37    0x1c    0x0c
0x7fffffffeb58: 0x27    0x26    0x2f    0x4b    0x12    0x7f    0x00    0x00
[...]
```
I then wrote a quick script to XOR the buffer with our `hiDd3n` string and swapped back the characters.

```py
flag = [0x00, 0x26, 0x13, 0x4b, 0x57, 0x51, 0x2c, 0x46,
0x1d, 0x2b, 0x46, 0x41, 0x2e, 0x06, 0x11, 0x0a,
0x77, 0x41, 0x5f, 0x21, 0x0d, 0x37, 0x1c, 0x0c,
0x27, 0x26, 0x2f, 0x4b, 0x12, 0x7f]

key = "hiDd3n"

def swap(i):
    match chr(i):
        case "_":
            return ord("/")
        case "/":
            return ord("_")
        case "+":
            return ord("-")
        case "-":
            return ord("+")
        case "!":
            return ord("?")
        case "?":
            return ord("!")
        case "#":
            return ord("@")
        case "@":
            return ord("#")
    return i

for i,v in enumerate(flag):
    v = v ^ ord(key[i%6])
    flag[i] = chr(swap(v))
print(''.join(flag))

```

```bash
➜ python3 ./solves/01_hidden.py
hOW_d!D_YOu_FoUnD_7HIS_bOOk_?
```
And *voila*, I spent too much time on this easy chall !



# EASY | Z80 Explorer

TBD

# Medium | Singularity

TBD

# Medium | The Prodigy

TBD
